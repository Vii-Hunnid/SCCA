// SCCA - Secure Compact Chat Architecture
// Prisma Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ═════════════════════════════════════════════════════════════════════════════
// USER MODEL
// Master key salt stored here - actual key derived at login
// ═════════════════════════════════════════════════════════════════════════════

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  image         String?
  passwordHash  String?   @map("password_hash")

  // OAuth provider info (null for credential users)
  oauthProvider String?   @map("oauth_provider")

  // Encryption - 16 byte random salt, base64 encoded
  masterKeySalt String    @map("master_key_salt")

  // Relations
  conversations SCCAConversation[]
  sessions      Session[]
  auditLogs     AuditLog[]
  apiKeys       ApiKey[]
  usageRecords  UsageRecord[]
  billingAccount BillingAccount?

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastLoginAt   DateTime? @map("last_login_at")

  @@index([email])
  @@map("users")
}

// ═════════════════════════════════════════════════════════════════════════════
// SESSION MODEL
// Tracks active sessions for auth
// ═════════════════════════════════════════════════════════════════════════════

model Session {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  token        String   @unique
  expiresAt    DateTime @map("expires_at")

  ipAddress    String?  @map("ip_address")
  userAgent    String?  @map("user_agent")

  createdAt    DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@map("sessions")
}

// ═════════════════════════════════════════════════════════════════════════════
// CONVERSATION MODEL
// SINGLE ROW PER CONVERSATION - This is the key SCCA optimization
// All messages stored as encrypted array in messageTokens (String[])
// ═════════════════════════════════════════════════════════════════════════════

model SCCAConversation {
  id            String   @id @default(cuid())
  userId        String   @map("user_id")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Metadata (unencrypted, searchable)
  title         String   @default("New Chat")
  model         String   @default("llama-3.3-70b-versatile")

  // CORE DATA: Array of encrypted message tokens
  // Each element is base64url-encoded packed binary (header + ciphertext + nonce)
  messageTokens String[] @map("message_tokens") @default([])

  // Cached count for quick access
  messageCount  Int      @default(0) @map("message_count")

  // Integrity verification - SHA-256 Merkle root of all messages
  merkleRoot    String?  @map("merkle_root")

  // Soft delete for GDPR compliance
  deletedAt     DateTime? @map("deleted_at")
  deletedBy     String?   @map("deleted_by")

  // Relations
  auditLogs     AuditLog[]
  mediaAttachments MediaAttachment[]

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([userId, updatedAt(sort: Desc)])
  @@index([userId, deletedAt])
  @@map("scca_conversations")
}

// ═════════════════════════════════════════════════════════════════════════════
// AUDIT LOG
// Immutable record of all actions for compliance and debugging
// ═════════════════════════════════════════════════════════════════════════════

model AuditLog {
  id              String   @id @default(cuid())
  userId          String   @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  conversationId  String?  @map("conversation_id")
  conversation    SCCAConversation? @relation(fields: [conversationId], references: [id])

  action          String   // 'create', 'edit', 'delete', 'view', 'regenerate', 'login', 'logout'
  details         Json?

  ipAddress       String?  @map("ip_address")
  userAgent       String?  @map("user_agent")

  createdAt       DateTime @default(now()) @map("created_at")

  @@index([userId, createdAt(sort: Desc)])
  @@index([conversationId, createdAt])
  @@index([action, createdAt])
  @@map("audit_logs")
}

// ═════════════════════════════════════════════════════════════════════════════
// API KEY MODEL
// Bearer token auth for external API access (Vault, Conversations)
// Key format: scca_k_<64-hex-chars> — only shown once at creation
// Only the SHA-256 hash is stored; prefix stored for display
// ═════════════════════════════════════════════════════════════════════════════

model ApiKey {
  id          String    @id @default(cuid())
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  name        String    // user-given label, e.g. "Production Backend"
  keyHash     String    @unique @map("key_hash") // SHA-256 of the full key
  keyPrefix   String    @map("key_prefix")        // first 12 chars for display: "scca_k_a1b2..."

  lastUsedAt  DateTime? @map("last_used_at")
  expiresAt   DateTime? @map("expires_at")
  revokedAt   DateTime? @map("revoked_at")

  // Usage tracking
  usageRecords UsageRecord[]

  createdAt   DateTime  @default(now()) @map("created_at")

  @@index([keyHash])
  @@index([userId])
  @@map("api_keys")
}

// ═════════════════════════════════════════════════════════════════════════════
// USAGE RECORD
// Tracks every API request for metering, billing, and rate limit enforcement.
// Modeled after OpenAI/Anthropic/xAI consumption tracking:
//   - Requests per minute (RPM), Requests per day (RPD)
//   - Tokens per minute (TPM), Tokens per day (TPD)
//   - Bytes processed (for Vault encrypt/decrypt)
// ═════════════════════════════════════════════════════════════════════════════

model UsageRecord {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  apiKeyId     String?  @map("api_key_id")
  apiKey       ApiKey?  @relation(fields: [apiKeyId], references: [id])

  // What happened
  endpoint     String   // e.g. "vault/encrypt", "vault/decrypt", "vault/verify", "conversations/messages"
  method       String   // "POST", "GET", etc.
  statusCode   Int      @map("status_code")

  // Metering
  requestTokens  Int    @default(0) @map("request_tokens")   // input tokens (prompt length / 4 approx)
  responseTokens Int    @default(0) @map("response_tokens")  // output tokens
  totalTokens    Int    @default(0) @map("total_tokens")     // request + response
  bytesIn        Int    @default(0) @map("bytes_in")         // request body size
  bytesOut       Int    @default(0) @map("bytes_out")        // response body size

  // Cost tracking (in microdollars: $0.01 = 10000 microdollars)
  costMicro      Int    @default(0) @map("cost_micro")

  // Timing
  latencyMs      Int    @default(0) @map("latency_ms")

  // Rate limit snapshot at time of request
  rateLimitTier  String @default("free") @map("rate_limit_tier")

  createdAt      DateTime @default(now()) @map("created_at")

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, endpoint, createdAt])
  @@index([apiKeyId, createdAt])
  @@index([createdAt])
  @@map("usage_records")
}

// ═════════════════════════════════════════════════════════════════════════════
// BILLING ACCOUNT
// Tracks user's billing tier, spend, and payment status.
// Tier system inspired by OpenAI/Anthropic usage tiers:
//   free → tier_1 → tier_2 → tier_3 → tier_4 → enterprise
// Each tier unlocks higher rate limits and quotas.
// ═════════════════════════════════════════════════════════════════════════════

model BillingAccount {
  id               String   @id @default(cuid())
  userId           String   @unique @map("user_id")
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Tier: "free", "tier_1", "tier_2", "tier_3", "tier_4", "enterprise"
  tier             String   @default("free")

  // Spend tracking (microdollars)
  totalSpendMicro  BigInt   @default(0) @map("total_spend_micro")   // lifetime spend
  monthlySpendMicro BigInt  @default(0) @map("monthly_spend_micro") // current billing period
  monthlyBudgetMicro BigInt @default(0) @map("monthly_budget_micro") // user-set monthly cap (0 = no cap)

  // Billing period
  billingCycleStart DateTime @default(now()) @map("billing_cycle_start")

  // Payment provider — Polar.sh integration
  polarCustomerId  String?  @unique @map("polar_customer_id")
  polarSubscriptionId String? @map("polar_subscription_id")
  polarProductId   String?  @map("polar_product_id")
  subscriptionStatus String? @map("subscription_status") // "active", "canceled", "past_due", "trialing"

  // Auto-tier upgrade
  autoUpgrade      Boolean  @default(false) @map("auto_upgrade")

  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  // Relations
  invoices         Invoice[]

  @@index([userId])
  @@index([tier])
  @@index([polarCustomerId])
  @@map("billing_accounts")
}

// ═════════════════════════════════════════════════════════════════════════════
// INVOICE
// Monthly billing records for each billing cycle.
// ═════════════════════════════════════════════════════════════════════════════

model Invoice {
  id               String   @id @default(cuid())
  billingAccountId String   @map("billing_account_id")
  billingAccount   BillingAccount @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)

  // Period
  periodStart      DateTime @map("period_start")
  periodEnd        DateTime @map("period_end")

  // Totals (microdollars)
  totalMicro       BigInt   @default(0) @map("total_micro")
  requestCount     Int      @default(0) @map("request_count")
  totalTokens      BigInt   @default(0) @map("total_tokens")
  totalBytes       BigInt   @default(0) @map("total_bytes")

  // Status: "draft", "pending", "paid", "overdue", "void"
  status           String   @default("draft")

  // Polar.sh order tracking
  polarOrderId     String?  @unique @map("polar_order_id")  // Polar order UUID
  polarInvoiceUrl  String?  @map("polar_invoice_url")       // Generated invoice URL
  billingReason    String?  @map("billing_reason")           // "purchase", "subscription_create", "subscription_cycle", "subscription_update"
  currency         String   @default("usd")

  createdAt        DateTime @default(now()) @map("created_at")

  @@index([billingAccountId, periodStart(sort: Desc)])
  @@index([status])
  @@index([polarOrderId])
  @@map("invoices")
}

// ═════════════════════════════════════════════════════════════════════════════
// MEDIA ATTACHMENT
// Encrypted media files attached to conversations via the SCCA media pipeline.
// ═════════════════════════════════════════════════════════════════════════════

model MediaAttachment {
  id               String   @id @default(cuid())
  conversationId   String   @map("conversation_id")
  conversation     SCCAConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId           String   @map("user_id")

  // Original file info
  originalName     String   @map("original_name")
  mimeType         String   @map("mime_type")
  originalSize     Int      @map("original_size")       // bytes

  // SCCA processing results
  encryptedSize    Int      @map("encrypted_size")      // bytes
  compressionRatio Float    @map("compression_ratio")   // e.g. 0.75 = 25% savings
  compressionMethod String  @map("compression_method")  // "none", "zlib-9"
  checksum         String                               // SHA-256 of original
  category         String                               // "image", "video", "audio", "document"

  // Encrypted data stored as base64
  encryptedData    String   @map("encrypted_data") @db.Text

  // Message association (sequence in the conversation)
  messageSequence  Int?     @map("message_sequence")

  createdAt        DateTime @default(now()) @map("created_at")

  @@index([conversationId])
  @@index([userId])
  @@map("media_attachments")
}
